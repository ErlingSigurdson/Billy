![ESP modules](https://i.imgur.com/5ZhI7Su.png)

# Общая информация

### Концепция
Билли - это программа (скетч) для фреймворка Ардуино, написанная для микроконтроллеров ESP32 и ESP8266.
С её помощью микроконтроллер может управлять нагрузкой посредством дискретного сигнала (ВКЛ./ВЫКЛ.)
и сигнала ШИМ, а также принимать команды по UART и по беспроводным сетям.

Далее по тексту название "Билли" может относиться как к самой программе, так и к устройству
(микроконтроллеру, модулю, плате разработки), на котором она выполняется.

### Страницы проекта
**GitHub**
[![github-en](https://img.shields.io/badge/github-en-blue)](https://github.com/ErlingSigurdson/Billy/blob/main/README.md)
[![github-ru](https://img.shields.io/badge/github-ru-blue)](https://github.com/ErlingSigurdson/Billy/blob/main/README.ru.md)

**GitFlic**
[![gitlfic-en](https://img.shields.io/badge/gitflic-en-red)](https://gitflic.ru/project/efimov-d-v/billy/blob?file=README.md&branch=main)
[![gitflic-ru](https://img.shields.io/badge/gitflic-ru-red)](https://gitflic.ru/project/efimov-d-v/billy/blob?file=README.ru.md&branch=main)

### Новости и этапы разработки
- **14.01.2024** - скетч успешно запущен на модуле ESP32-C6 с использованием
[альфа-версии 3.0.0-alpha3 ядра Ардуино для ESP32 от Espressif Systems](https://github.com/espressif/arduino-esp32/milestone/4).
- **25.06.2024** - релиз версии 1.3 со следующими важными изменениями:
    - добавлена поддержка управления сигналом ШИМ, в связи с чем название проекта изменено
      с "Релешка Билли" на просто "Билли";
    - проведён значительный рефакторинг кода, в частности, функции-обработчики команд
      теперь объявлены и определены не в файле .ino, а в отдельных файлах;
    - добавлена функция автоматического перезапуска локального TCP-сервера после восстановления
      подключения к точке доступа;
    - добавлена проверка данных при вводе новых значений настроек. 
- **25.06.2024** - релиз версии 1.3.1, в веб-интерфейс добавлена панель управления сигналом ШИМ.

### Дальнейшие планы
1. Добавить поддержку Bluetooth Low Energy (BLE).
2. Добавить возможность переключения Wi-Fi между режимом станции и режимом точки доступа,
   в том числе без перезагрузки устройства.


***
# Руководство

### Управление нагрузкой
Для управления нагрузкой Билли использует два вывода GPIO - один для дискретного сигнала и один для сигнала ШИМ.

Типичной для Билли нагрузкой можно считать:
- при управлении дискретным сигналом - электромеханическое реле с драйвером на транзисторе или оптопаре;
- при управлении сигналом ШИМ - электромотор с драйвером на КМОП-транзисторе (MOSFET);
- при управлении любым видом сигнала - светодиод (обычно используется для проверки работы устройства).

### Индикаторный светодиод
Билли использует один дополнительный вывод GPIO для дискретного управления индикаторным светодиодом,
сигнализирующим о статусе Wi-Fi. Редкие мигания означают попытки подключиться к сети,
частые мигания - успешное подключение.

### Совмещение выводов
Не следует совмещать выводы дискретного сигнала и сигнала ШИМ - обычно это делает управление дискретным
сигналом невозможным.

Совмещать выводы дискретного управления нагрузкой и светодиодом допускается, но это будет означать,
что светодиод и есть нагрузка.

### Отключение выводов
Вывод можно отключить, указав 0 в качестве значения соответствующей директивы `#define` в файле
`config_general.h`.

### Коммуникации
Направлять Билли команды можно:
- по UART через кабель;
- по Wi-Fi как локальному TCP-серверу, например, с помощью классической Unix-утилиты `netcat` (`nc`)
или приложения для Android [Serial Wi-Fi terminal](https://serial-wifi-terminal.en.softonic.com/android); 
- по Wi-Fi как локальному HTTP-серверу, например, с помощью веб-браузера (скетч предоставляет минималистичный
веб-интерфейс) или иного приложения для отправки HTTP-запросов;
- по Bluetooth Classic как ведомому устройству[^1], например, с помощью Bluetooth-терминала для рабочего стола
или приложения для Android [Serial Bluetooth Controller](https://bluetooth-serial-controller.en.softonic.com/android).
- по Wi-Fi как TCP-клиенту (в том числе через Интернет). Для этого Билли направляет запросы специально настроенному
TCP-серверу и в ответ получает от него команды (этот способ более детально описан ниже).

Билли предназначен для работы в сети Wi-Fi в режиме клиента (station, STA).
Доступ в Интернет Билли получает через точку доступа.

### IoT: Билли как TCP-клиент и управление через Интернет
Удалённый TCP-сервер, к которому обращается Билли (в том числе через Интернет), должен уметь:
- в ответ на направляемый Билли запрос (например, строку `"AT+SERVERTOPIC"`) направлять ему сообщение (тоже строку),
содержащее одну из валидных команд;
- изменять сообщение, заготовленное в качестве ответа на запрос Билли, согласно передаваемым самому серверу
дистанционным командам.

Например, сервер, получив с вашей рабочей станции дистанционную команду "включить нагрузку", готовится в ответ
на следующий запрос Билли отправить ему команду `AT+LOADDIGITAL=ON`. Билли в роли TCP-клиента принимает команду
и обрабатывает её так же, как полученную по любому другому каналу связи.

[Здесь вы можете найти готовый код работающего таким образом сервера для Linux](https://github.com/ErlingSigurdson/server0451/tree/main),
написанный на языке С. Он рассчитан как раз на взаимодействие с Билли и подобными ему устройствами.

### Хранение настроек
Билли широко использует флеш-накопитель, встроенный в микроконтроллер или распаянный на одном с ним модуле.
Благодаря этому задать настройки (ввести SSID и пароль от сети Wi-Fi, задать номер порта и т. д.) достаточно один раз,
после перезагрузки устройства все данные сохранятся.

Текущее состояние нагрузки (текущий уровень дискретного сигнала, скважность ШИМ) не считается настройкой
и поэтому не хранится во флеш-накопителе. После перезагрузки устройства нагрузка будет отключена.

### Полный список команд
Полный список команд и их описание приведены в файле `confid_cmd.h`.

### Быстрый старт
Чтобы сконфигурировать скетч, загрузить его, задать настройки и опробовать Билли, выполните следующие шаги:

1. В файле `config_general.h`:
- назначьте вывод дискретного сигнала, присвоив значение директиве `#define DIGITAL_OUTPUT_PIN`;
- назначьте вывод сигнала ШИМ, присвоив значение директиве `#define PWM_OUTPUT_PIN`;
- назначьте вывод управления индикаторным светодиодом, присвоив значение директиве `#define WIFI_INDICATOR_LED_PIN`;
- раскомментируйте директиву `#define INVERTED_DIGITAL_OUTPUT`, если ваша дискретно управляемая нагрузка включается
при низком уровне дискретного сигнала;
- закомментируйте директиву `#define BT_CLASSIC_PROVIDED`, если ваш модуль ESP32 не поддерживает Bluetooth Classic
или вы просто не планируете его использовать. Для ESP8266 игнорируйте.
2. Убедитесь, что в Arduino IDE (или в SDK Arduino в другой используемой вами IDE) добавлено соответствующее ядро
для совместимости [ESP32](https://github.com/espressif/arduino-esp32) или [ESP8266](https://github.com/esp8266/Arduino)
с фреймворком Ардуино, разработанное компанией Espressif Systems.
3. Скомпилируйте скетч и загрузите его в своё устройство.[^2]
4. Включите устройство и подключитесь к нему через кабель (через USB-UART преобразователь или, если это поддерживается
вашим устройством, через UART поверх нативного USB).
5. Откройте косоль последовательного соединения и выберите нужное значение бод (по умолчанию 115200).
6. С помощью команды `AT+WIFISSID=<значение>` введите SSID точки доступа сети Wi-Fi.
7. С помощью команды `AT+WIFIPSWD=<значение>` введите пароль точки доступа сети Wi-Fi.
8. С помощью команды `AT+LOCALPORT=<значение>` задайте номер порта, который Билли будет использовать как локальный
TCP-сервер.
9. Перезагрузите устройство или введите команду `AT+ALLCONNRST`.
10. Убедитесь, что Билли подключился к сети Wi-Fi.
11. С помощью команд `AT+LOADDIGITAL=ON`, `AT+LOADDIGITAL=OFF`, `AT+LOADDIGITAL=TOGGLE`
и `AT+LOADPWM=<значение от 0 до 255>`, передаваемых через UART или через консоль передачи данных по Wi-Fi, поуправляйте
подключенной к соответствующим выводам нагрузкой.
12. Откройте любой браузер и наберите в адресной строке IP-адрес Билли в сети Wi-Fi. Попробуйте поуправлять нагрузкой
через открывшийся веб-интерфейс.

Чтобы опробовать функционал Bluetooth Classic (если он поддерживается):

1. С помощью команды `AT+BTCLASSICDEVNAME=<значение>` задайте имя устройства как ведомого устройства Bluetooth Classic.
2. С помощью команды `AT+BTCLASSIC=ON` включите функционал Bluetooth Classic.
3. Попробуйте управлять нагрузкой с помощью тех же команд, которые вы применяли ранее.

Чтобы опробовать функционал IoT:

1. С помощью команды `AT+IOTIP=<значение>` задайте IP-адрес удалённого сервера, который будет сообщать Билли команды.
2. С помощью команды `AT+IOTPORT=<значение>` задайте порт удалённого сервера, готовый принимать запросы от Билли. 
3. С помощью команды `AT+IOTREQMSG=<значение>` задайте соответствующий настройкам сервера текст запроса.
4. С помощью команды `AT+IOT=ON` включите функционал IoT.
5. Убедитесь, что Билли получает команды от удалённого сервера.


***
# Общие примечания к коду

### Разделение проекта на файлы
Разделение исходного кода самого скетча на основной файл `.ino` и локальные файлы `.h` и `.cpp` - не очень популярный
подход при написании скетчей для Ардуино (чаще используется вариант с несколькими файлами `.ino`, которые перед
компиляцией конкатенируются средой разработки, либо с упаковкой кода в библиотеки), но оно имеет преимущество в виде
более прозрачной структуры кода.

### Глобальные переменные
Дополнительные глобальные переменные нарочито не вводятся, поскольку "общим пространством" для различных функций скетча
служит накопитель устройства. Исключение - некоторые флаги и экземпляры классов (таких как `WiFiServer`,
`BluetoothSerial` и т. д.).

### Модули и функции-врапперы
Вызовы методов в основном обёрнуты в функции-врапперы, объявленные в локальных модулях (файлах `.h` и `.cpp`).
Это удобно, поскольку каждому вызову метода, как правило, сопутствуют связанные с ним дополнительные строки кода.

Модули в основном не ссылаются друг на друга, вместо этого относящиеся к ним функции-врапперы вызываются в коде,
содержащемся в файлах `Billy.ino` и `cmd.cpp`. Благодаря этому упрощается допиливание скетча под конкретные нужды.


***
# Справедливые вопросы

### Почему не MQTT, ведь он отлично подходит для "Интернета вещей"?
Хотелось обеспечить больше гибкости и не хотелось привязываться к определённому протоколу 7-го уровня модели OSI.

### Почему "Билли"?
В честь попугая-программиста, героя
[мемных видео](https://www.youtube.com/watch?v=0MhVkKHYUAY&list=PLkdGijFCNuVmu35l6EJxdvsvf7xj4EQVf&index=21)
от [Mr. P Solver](https://www.youtube.com/c/mrpsolver).

### Что насчёт безопасности?
В рамках вашей домашней сети Wi-Fi ваша лучшая защита - это пароль точки доступа. Вы можете даже развернуть
на вашем роутере дополнительную сеть Wi-Fi, которая будет использоваться только для Билли и прочих устройств IoT.

Что касается безопасности при использовании Bluetooth, вы можете в файле `config_cmd.h` изменить префикс команд,
чтобы они имели вид `ATMYPSWD+LOADDIGITAL=TOGGLE`, таким образом фактически задав устройству пароль.

[^1]: Не работает для ESP8266 и моделей в линейке ESP32 без поддержки Bluetooth Classic (например, ESP32-S2 и ESP32-C3).
[^2]: Если среда разработки сообщает о недостатке у ESP32 памяти для загрузки скетча, попробуйте изменить опцию
`partition scheme` на "Huge APP".
